---
layout: post
title: "RustでCコンパイラ その07 Claude Codeにアセンブリデバッグツールを作ってもらった(番外編)"
tags : [Rust]
date: 2026-02-12 21:34:44
---


下記をRustで実装する続き。

なんだけど、今回は少し違って、アセンブリデバッグ用のツールをClaude Codeに作ってもらった話


[低レイヤを知りたい人のためのCコンパイラ作成入門](https://www.sigbus.info/compilerbook)


Githubは下記。
特に gdb ディレクトリが今回は重要。

[ryotakato/tvcc](https://github.com/ryotakato/tvcc)




さて、本来は先のSTEPへ行きたいのだが、
その前に、アセンブリデバッグ時の辛さをなんとかしたいと思って、
どうも手が伸びなかった（あと、レポートが忙しいのもあり）

最近Claude Codeを始めてみたので、
あ、それなら作ってもらえば良いんじゃないかと思ってやってみた。



今までは gdb を使ってデバッグしているのだけど、
スタックの値が見れないのが面倒だった。

そもそも、Mac M4 + Docker Linux で作っているから、余計に複雑。
ざっと、ビルドの流れをまとめると、

1. Rustのcrossビルドで、コンパイラ本体をx86_64用にビルド
2. そのコンパイラで、DockerのLinux内にて、Cもどきをコンパイル。
3. 結果、x86_64用のアセンブリができる。
4. それを実行ファイルにしてから実行するが、デバッグ時のgdbは、 Rosetta 2 でサーバとして動かし、そこにつなげにいかないといけない。

という感じになっている。


最初にClaude Codeに相談したとき、
ひとまず gefや、pwndbg を使うのはどうだって言われて、
実際に試してみたのだけど、 Roseta 2 で動いているためか、 どちらも実行したらエラーになってしまう。
解決策を探したけど、どうも無理そうだったので、
渋々ながら、 Python と Pythonの gdbライブラリを使って作ってもらうことにした。

まだそこまでClaude Codeを信頼してなかったので、
まあ、動かないものができたり、全然違うものが作られるのだろうなって思っていた。

しかし、プランモードでスタートして計画を考えさせたせいか、
あっという間に満足のいくものができた。

これはサンプルプログラムをデバッグしているときの画像。

![c_compiler_by_rust_07_01]({{ BASE_PATH }}/images/2026/02/12/c_compiler_by_rust_07_01.png)


REGISTERの色が変わっているところは前回からの変更点
Stackも表示してくれて、どこがRSPか、RBPかも示してくれる。
もちろんDisassemlyで今どこにいるかも表示。


これをステップ実行するたびに表示してくれるからめっちゃ助かる。


なお、いくつかClaude Codeに聞かれて、それを答えてってやった結果の設計は下記ファイルに出力してもらった。
将来のideaも追記してくれたし、言うことなし。


[tvcc/doc/gdb-context-display.md at main · ryotakato/tvcc](https://github.com/ryotakato/tvcc/blob/main/doc/gdb-context-display.md)





正直、AIを使うコーディングは、舐めていたところあるが、
このレベルでこっちの期待するものを汲んでくれるなら、全然ありだな。







